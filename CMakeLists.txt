#Specify minimum version of CMake required
cmake_minimum_required(VERSION 3.24)

#Print out extra messages to see exactly what CMAKE is up to 
set(CMAKE_VERBOSE_MAKEFILE ON)

include(FetchContent)
FetchContent_Declare(
  WLA-DX
  URL  https://github.com/vhelin/wla-dx/releases/download/v10.6/wla_dx_v10.6_Win64.zip
  URL_HASH   MD5=8ec046f9ef7b8b695d9186c7f679a5f6
)
FetchContent_MakeAvailable(WLA-DX)

#Tell CMake where to look for Cmake files for Compiler Test and Information
list(APPEND CMAKE_PREFIX_PATH "${CMAKE_CURRENT_LIST_DIR}/_cmake")
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/_cmake")

#Path to toolchain file - this is placed before call to project(###)
set(CMAKE_TOOLCHAIN_FILE ${CMAKE_SOURCE_DIR}/_toolchain/wla-z80.cmake)

#Set up Project name, version, description and source code language
project(SMS VERSION 1.0
            DESCRIPTION "SMS Build System"
            LANGUAGES ASM-Z80)

#Set what extension do compiled z80 asm object files have
set(CMAKE_ASM_Z80_OUTPUT_EXTENSION ".o")

#Optional message to make sure that toolchain has been located
message(STATUS "CMAKE_TOOLCHAIN_FILE is: ${CMAKE_TOOLCHAIN_FILE}")

get_filename_component(EXECUTABLE_NAME ${CMAKE_CURRENT_SOURCE_DIR} NAME) #Let's name the build target after the current directory name
string(REPLACE " " "_" EXECUTABLE_NAME ${EXECUTABLE_NAME}) # if we were daft and put spaces in the directory name change them to underscores

set(EXECUTABLE ${EXECUTABLE_NAME}.sms) #this is the name of the executable produced by the build process
#list of source files to be compiled that are used in the project
set(SRC_FILES
   src/main.asm )

#build executables based on source files
add_executable(${EXECUTABLE} ${SRC_FILES})

#list of include directories
target_include_directories(${EXECUTABLE} PRIVATE
    include)

set( LINK_FILE "${CMAKE_CURRENT_BINARY_DIR}/linkfile") #Create a shorter variable to hold the directory and name of the linkfile
#add rule to generate linker file beofre linking occurs
add_custom_command(
    TARGET ${EXECUTABLE} #target for command
    PRE_LINK             #when command occurs
    COMMAND echo [objects]>${LINK_FILE}    ##create a linkfile file in the current dir, add "[objects]" as opening line of file
    )

foreach(_file $<TARGET_OBJECTS:${EXECUTABLE}>) #a for loop that cycles over each file generated by the compiler
  add_custom_command(
    TARGET ${EXECUTABLE}  #target is for this executable
    PRE_LINK              #This command is carreid out prior to linking
    
    COMMAND echo ${_file} >> ${LINK_FILE}   #add each file to the linkfile
  )
endforeach()

#set linker options
set(CMAKE_EXE_LINKER_FLAGS "${ASM-Z80_LINKER_FLAGS} ${LINK_FILE} ${CMAKE_CURRENT_BINARY_DIR}/${EXECUTABLE}")

#set a property to clean out any files under the binary directory so that all files related to compiled binary are removed on clean
set_property(
        TARGET ${EXECUTABLE}
        APPEND
        PROPERTY ADDITIONAL_CLEAN_FILES ${CMAKE_CURRENT_BINARY_DIR}
)

